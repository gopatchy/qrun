<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Qrun</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #111;
  --bg2: #1a1a1a;
  --fg: #eee;
  --fg-dim: #888;
  --border: #333;
  --cue-color: #f72;
  --cue-bg: rgba(58, 24, 0, 0.7);
  --light-color: #c8e;
  --light-bg: rgba(42, 10, 42, 0.55);
  --video-color: #4d4;
  --video-bg: rgba(10, 42, 10, 0.55);
  --overlay-color: #2cb;
  --overlay-bg: rgba(10, 34, 34, 0.55);
  --audio-color: #58f;
  --audio-bg: rgba(10, 10, 42, 0.55);
  --delay-color: #999;
  --delay-bg: rgba(26, 26, 26, 0.55);
  --infinity-color: #666;
}

html, body {
  background: var(--bg);
  color: var(--fg);
  font-family: "SF Mono", "Menlo", "Consolas", "DejaVu Sans Mono", monospace;
  font-size: 13px;
  line-height: 1.4;
  height: 100%;
  overflow: hidden;
}

.app { display: flex; flex-direction: column; height: 100%; }

header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 16px; background: var(--bg2);
  border-bottom: 1px solid var(--border); flex-shrink: 0;
}
header h1 { font-size: 16px; font-weight: 600; letter-spacing: 0.05em; }
.header-status { display: flex; gap: 16px; align-items: center; font-size: 12px; color: var(--fg-dim); }
.status-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #4d4; margin-right: 4px; }

.timeline-container { flex: 1; overflow: auto; }

.timeline {
  display: grid;
  grid-auto-rows: 24px;
}

.track-header {
  position: sticky; top: 0; z-index: 10;
  padding: 6px 8px; font-size: 10px; font-weight: 600;
  text-transform: uppercase; letter-spacing: 0.08em; text-align: center;
  border-bottom: 2px solid var(--border); border-right: 1px solid var(--border);
  background: var(--bg2); color: var(--fg-dim);
}

.cell {
  border-right: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  padding: 0; position: relative;
  display: flex; flex-direction: column;
  justify-content: center;
}

.block {
  margin: 0 3px; position: relative; z-index: 1; flex: 1;
  display: flex; align-items: center; justify-content: center;
}
.block-start {
  border-top: 2px solid; border-left: 2px solid; border-right: 2px solid;
  border-top-left-radius: 3px; border-top-right-radius: 3px;
  margin-top: 1px; margin-bottom: -1px;
}
.block-mid {
  border-left: 2px solid; border-right: 2px solid;
  margin-top: -1px; margin-bottom: -1px; min-height: 4px;
}
.block-end {
  border-bottom: 2px solid; border-left: 2px solid; border-right: 2px solid;
  border-bottom-left-radius: 3px; border-bottom-right-radius: 3px;
  margin-top: -1px; margin-bottom: 1px;
}
.block-single {
  border: 2px solid; border-radius: 3px; margin: 1px 3px;
}

.block.cue { color: var(--cue-color); border-color: var(--cue-color); background: var(--cue-bg); }

.cell.cue-row {
  background: rgba(255, 119, 34, 0.12);
  border-top: 1px solid var(--cue-color);
  border-bottom: 1px solid var(--cue-color);
}

.cell.sig-row {
  background: rgba(255, 204, 0, 0.07);
  border-top: 1px solid rgba(255, 204, 0, 0.3);
  border-bottom: 1px solid rgba(255, 204, 0, 0.3);
}
.block.light { color: var(--light-color); border-color: var(--light-color); background: var(--light-bg); }
.block.video { color: var(--video-color); border-color: var(--video-color); background: var(--video-bg); }
.block.overlay { color: var(--overlay-color); border-color: var(--overlay-color); background: var(--overlay-bg); }
.block.audio { color: var(--audio-color); border-color: var(--audio-color); background: var(--audio-bg); }
.block.delay { color: var(--delay-color); border-color: var(--delay-color); background: var(--delay-bg); }

.hook {
  font-size: 8px; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.06em; opacity: 0.8;
}

.sig {
  background: #fc0;
  color: #000;
  border-radius: 2px;
  padding: 0 6px;
  font-weight: 700;
}

.hk {
  border: 1px solid #fc0;
  border-radius: 2px;
  padding: 0 5px;
}

.title {
  text-align: center; font-size: 11px; font-weight: 500;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

.cue-label {
  font-size: 10px; font-weight: 600; color: var(--cue-color);
  padding: 0 4px;
}

.infinity-cell { position: relative; overflow: hidden; }
.infinity-cell .block { border-bottom: none !important; border-bottom-left-radius: 0 !important; border-bottom-right-radius: 0 !important; }
.infinity-marker {
  position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);
  font-size: 9px; color: var(--infinity-color);
  letter-spacing: 0.1em; z-index: 1; white-space: nowrap;
}
</style>
</head>
<body>
<div class="app">
<header>
  <h1>QRUN</h1>
  <div class="header-status" id="header-status"></div>
</header>
<div class="timeline-container">
<div class="timeline" id="timeline"></div>
</div>
</div>
<script>
fetch('show.json').then(r => r.json()).then(render);

function render(data) {
  const blockMap = new Map(data.blocks.map(b => [b.id, b]));
  const trackIds = data.tracks.map(t => t.id);
  const trackType = new Map(data.tracks.map(t => [t.id, t.type]));

  const triggerTargetSet = new Set();
  const triggerSourceSet = new Set();
  data.triggers.forEach(t => {
    triggerSourceSet.add(t.source);
    t.targets.forEach(tgt => triggerTargetSet.add(tgt));
  });

  const trackBlocks = new Map();
  trackIds.forEach(id => trackBlocks.set(id, []));
  data.blocks.forEach(b => trackBlocks.get(b.track).push(b.id));

  document.getElementById('header-status').innerHTML =
    '<span><span class="status-dot"></span>QLab Connected</span>' +
    '<span>Show: ' + data.show + '</span>' +
    '<span>Cue: ' + data.blocks.filter(b => b.track === 'cue').length + '</span>';

  const active = new Map();
  const pendingEnds = new Set();
  const pendingTitles = new Set();
  const rows = [];
  function btype(blockId) {
    const b = blockMap.get(blockId);
    return b.type || trackType.get(b.track);
  }

  function nextInTrack(blockId) {
    const b = blockMap.get(blockId);
    const seq = trackBlocks.get(b.track);
    const idx = seq.indexOf(blockId);
    return idx < seq.length - 1 ? seq[idx + 1] : null;
  }

  function mid(tid) {
    const a = active.get(tid);
    return a ? { blockId: a, segment: 'mid' } : { empty: true };
  }

  function addRow(cells, rowClass) {
    rows.push({ cells, rowClass: rowClass || '' });
  }

  function canAutoStart(bid) {
    const ref = bid + ':start';
    return !triggerTargetSet.has(ref) && !triggerSourceSet.has(ref);
  }

  function emitTitles() {
    if (pendingTitles.size === 0) return;
    const cells = trackIds.map(tid => {
      const t = [...pendingTitles].find(bid => blockMap.get(bid).track === tid);
      return t ? { blockId: t, segment: 'mid', title: blockMap.get(t).name } : mid(tid);
    });
    addRow(cells);
    pendingTitles.clear();
  }

  function doAutoStarts(ended) {
    const starts = [];
    ended.forEach(bid => {
      const next = nextInTrack(bid);
      if (next && canAutoStart(next)) starts.push(next);
    });
    if (starts.length === 0) return;
    const cells = trackIds.map(tid => {
      const s = starts.find(bid => blockMap.get(bid).track === tid);
      if (s) {
        active.set(tid, s);
        pendingTitles.add(s);
        return { blockId: s, segment: 'start', event: 'start' };
      }
      return mid(tid);
    });
    addRow(cells);
  }

  function flush(upcomingSource) {
    emitTitles();
    if (pendingEnds.size === 0) return;

    const holdBack = new Set();
    if (upcomingSource) {
      for (const bid of pendingEnds) {
        if (upcomingSource === bid + ':end') holdBack.add(bid);
      }
    }

    const toEnd = [...pendingEnds].filter(bid => !holdBack.has(bid));
    if (toEnd.length === 0) return;

    const cells = trackIds.map(tid => {
      const e = toEnd.find(bid => blockMap.get(bid).track === tid);
      return e ? { blockId: e, segment: 'end', event: 'end' } : mid(tid);
    });
    addRow(cells);
    toEnd.forEach(bid => { active.delete(blockMap.get(bid).track); pendingEnds.delete(bid); });

    doAutoStarts(toEnd);
    emitTitles();
  }

  function processTrigger(trigger) {
    const source = trigger.source;
    const isCue = !source.includes(':');

    flush(source);

    if (!isCue) {
      const [srcBlock, srcEvent] = source.split(':');
      const b = blockMap.get(srcBlock);
      if (srcEvent === 'start') {
        const cur = active.get(b.track);
        if (cur && cur !== srcBlock) {
          pendingEnds.delete(cur);
          const cells = trackIds.map(tid =>
            tid === b.track ? { blockId: cur, segment: 'end', event: 'end' } : mid(tid)
          );
          addRow(cells);
          active.delete(b.track);
        }
        active.set(b.track, srcBlock);
      }
    }

    emitTitles();

    const rowClass = isCue ? 'cue-row' : 'sig-row';

    const targetMap = new Map();
    trigger.targets.forEach(t => {
      const p = t.split(':');
      targetMap.set(p[0], p[1]);
    });

    const directEnds = [];

    const cells = trackIds.map(tid => {
      if (isCue && tid === 'cue')
        return { cueLabel: blockMap.get(source).name };

      if (!isCue) {
        const [srcBlock, srcEvent] = source.split(':');
        if (blockMap.get(srcBlock).track === tid) {
          const seg = srcEvent === 'start' ? 'start' : srcEvent === 'end' ? 'end' : 'mid';
          return { blockId: srcBlock, segment: seg, event: srcEvent, isSignal: true };
        }
      }

      const entry = [...targetMap.entries()].find(([bid]) => blockMap.get(bid).track === tid);
      if (entry) {
        const [bid, evt] = entry;
        const isHook = !isCue;
        if (evt === 'start') {
          active.set(tid, bid);
          pendingTitles.add(bid);
          return { blockId: bid, segment: 'start', event: 'start', isHook };
        }
        if (evt === 'end') {
          directEnds.push(bid);
          return { blockId: bid, segment: 'end', event: 'end', isHook: isHook };
        }
        if (evt === 'fade_out') {
          pendingEnds.add(bid);
          return { blockId: bid, segment: 'mid', event: 'fade_out' };
        }
      }

      return mid(tid);
    });

    addRow(cells, rowClass);

    directEnds.forEach(bid => active.delete(blockMap.get(bid).track));
    doAutoStarts(directEnds);

    if (!isCue) {
      const [srcBlock, srcEvent] = source.split(':');
      if (srcEvent === 'start') pendingTitles.add(srcBlock);
      if (srcEvent === 'fade_out') pendingEnds.add(srcBlock);
      if (srcEvent === 'end') {
        active.delete(blockMap.get(srcBlock).track);
        pendingEnds.delete(srcBlock);
        doAutoStarts([srcBlock]);
      }
    }
  }

  data.triggers.forEach(t => processTrigger(t));
  flush(null);
  emitTitles();

  const infBlocks = data.blocks.filter(b => b.infinity);
  if (infBlocks.length > 0) {
    const cells = trackIds.map(tid => {
      const inf = infBlocks.find(b => b.track === tid);
      return inf ? { blockId: inf.id, segment: 'mid', infinity: true } : mid(tid);
    });
    addRow(cells);
  }

  const timeline = document.getElementById('timeline');
  timeline.style.gridTemplateColumns = 'repeat(' + trackIds.length + ', 140px)';

  data.tracks.forEach(t => {
    const th = document.createElement('div');
    th.className = 'track-header';
    th.textContent = t.name;
    timeline.appendChild(th);
  });

  rows.forEach(row => {
    row.cells.forEach(cell => {
      const div = document.createElement('div');
      let cls = 'cell';
      if (row.rowClass) cls += ' ' + row.rowClass;

      if (cell.cueLabel) {
        div.className = cls;
        const label = document.createElement('div');
        label.className = 'cue-label';
        label.textContent = cell.cueLabel;
        div.appendChild(label);
      } else if (cell.empty) {
        div.className = cls;
      } else if (cell.title) {
        div.className = cls;
        const block = document.createElement('div');
        block.className = 'block block-mid ' + btype(cell.blockId);
        const t = document.createElement('div');
        t.className = 'title';
        t.textContent = cell.title;
        block.appendChild(t);
        div.appendChild(block);
      } else if (cell.infinity) {
        div.className = cls + ' infinity-cell';
        const block = document.createElement('div');
        block.className = 'block block-mid ' + btype(cell.blockId);
        div.appendChild(block);
        const marker = document.createElement('div');
        marker.className = 'infinity-marker';
        marker.innerHTML = '&#x223F;&#x223F;&#x223F;';
        div.appendChild(marker);
      } else {
        div.className = cls;
        const seg = cell.segment || 'mid';
        const block = document.createElement('div');
        block.className = 'block block-' + seg + ' ' + btype(cell.blockId);
        if (cell.event) {
          const hook = document.createElement('div');
          let hookCls = 'hook';
          if (cell.isSignal) hookCls += ' sig';
          else if (cell.isHook) hookCls += ' hk';
          hook.className = hookCls;
          hook.textContent = cell.event.replace('_', ' ');
          block.appendChild(hook);
        }
        div.appendChild(block);
      }

      timeline.appendChild(div);
    });
  });
}
</script>
</body>
</html>
