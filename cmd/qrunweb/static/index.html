<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Qrun</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #111;
  --bg2: #1a1a1a;
  --fg: #eee;
  --fg-dim: #888;
  --border: #333;
  --cue-color: #f72;
  --cue-bg: rgba(58, 24, 0, 0.7);
  --light-color: #c8e;
  --light-bg: rgba(42, 10, 42, 0.55);
  --video-color: #4d4;
  --video-bg: rgba(10, 42, 10, 0.55);
  --audio-color: #58f;
  --audio-bg: rgba(10, 10, 42, 0.55);
  --delay-color: #999;
  --delay-bg: rgba(26, 26, 26, 0.55);
  --infinity-color: #666;
}

html, body {
  background: var(--bg);
  color: var(--fg);
  font-family: "SF Mono", "Menlo", "Consolas", "DejaVu Sans Mono", monospace;
  font-size: 13px;
  line-height: 1.4;
  height: 100%;
  overflow: hidden;
}

.app { display: flex; flex-direction: column; height: 100%; }

header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 16px; background: var(--bg2);
  border-bottom: 1px solid var(--border); flex-shrink: 0;
}
header h1 { font-size: 16px; font-weight: 600; letter-spacing: 0.05em; }
.header-status { display: flex; gap: 16px; align-items: center; font-size: 12px; color: var(--fg-dim); }
.status-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #4d4; margin-right: 4px; }

.timeline-container { flex: 1; overflow: auto; }

.timeline {
  display: grid;
  grid-auto-rows: 24px;
}

.track-header {
  position: sticky; top: 0; z-index: 10;
  padding: 6px 8px; font-size: 10px; font-weight: 600;
  text-transform: uppercase; letter-spacing: 0.08em; text-align: center;
  border-bottom: 2px solid var(--border); border-right: 1px solid var(--border);
  background: var(--bg2); color: var(--fg-dim);
}

.cell {
  border-right: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  padding: 0; position: relative;
  display: flex; flex-direction: column;
  justify-content: center;
}

.block {
  margin: 0 3px; position: relative; z-index: 1; flex: 1;
  display: flex; align-items: center; justify-content: center;
}
.block-start {
  border-top: 2px solid; border-left: 2px solid; border-right: 2px solid;
  border-top-left-radius: 3px; border-top-right-radius: 3px;
  margin-top: 1px; margin-bottom: -1px;
}
.block-mid {
  border-left: 2px solid; border-right: 2px solid;
  margin-top: -1px; margin-bottom: -1px; min-height: 4px;
}
.block-end {
  border-bottom: 2px solid; border-left: 2px solid; border-right: 2px solid;
  border-bottom-left-radius: 3px; border-bottom-right-radius: 3px;
  margin-top: -1px; margin-bottom: 1px;
}
.block-single {
  border: 2px solid; border-radius: 3px; margin: 1px 3px;
}

.block.cue { color: var(--cue-color); border-color: var(--cue-color); background: var(--cue-bg); }

.cell.cue-row {
  background: rgba(255, 119, 34, 0.12);
  border-top: 1px solid var(--cue-color);
  border-bottom: 1px solid var(--cue-color);
}

.cell.sig-row {
  background: rgba(255, 204, 0, 0.07);
  border-top: 1px solid rgba(255, 204, 0, 0.3);
  border-bottom: 1px solid rgba(255, 204, 0, 0.3);
}
.block.light { color: var(--light-color); border-color: var(--light-color); background: var(--light-bg); }
.block.video { color: var(--video-color); border-color: var(--video-color); background: var(--video-bg); }
.block.audio { color: var(--audio-color); border-color: var(--audio-color); background: var(--audio-bg); }
.block.delay { color: var(--delay-color); border-color: var(--delay-color); background: var(--delay-bg); }

.hook {
  font-size: 8px; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.06em; opacity: 0.8;
}

.sig {
  background: #fc0;
  color: #000;
  border-radius: 2px;
  padding: 0 6px;
  font-weight: 700;
}

.hk {
  border: 1px solid #fc0;
  border-radius: 2px;
  padding: 0 5px;
}

.title {
  text-align: center; font-size: 11px; font-weight: 500;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

.cue-label {
  font-size: 10px; font-weight: 600; color: var(--cue-color);
  padding: 0 4px;
}

.infinity-cell { position: relative; overflow: hidden; }
.infinity-cell .block { border-bottom: none !important; border-bottom-left-radius: 0 !important; border-bottom-right-radius: 0 !important; }
.infinity-marker {
  position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);
  font-size: 9px; color: var(--infinity-color);
  letter-spacing: 0.1em; z-index: 1; white-space: nowrap;
}
</style>
</head>
<body>
<div class="app">
<header>
  <h1>QRUN</h1>
  <div class="header-status" id="header-status"></div>
</header>
<div class="timeline-container">
<div class="timeline" id="timeline"></div>
</div>
</div>
<script>
fetch('show.json').then(r => r.json()).then(render);

function render(data) {
  const blockMap = new Map(data.blocks.map(b => [b.id, b]));
  const CUE_TRACK = '_cue';
  const trackIds = [CUE_TRACK, ...data.tracks.map(t => t.id)];

  function ref(b, s) { return b + ':' + s; }

  const triggerSourceSet = new Set();
  data.triggers.forEach(t => triggerSourceSet.add(ref(t.source.block, t.source.signal)));

  function blockTrack(bid) {
    const b = blockMap.get(bid);
    return b.type === 'cue' ? CUE_TRACK : b.track;
  }

  function isChain(trigger) {
    const src = trigger.source;
    if (src.signal !== 'END' || trigger.targets.length !== 1) return false;
    return trigger.targets[0].hook === 'START' &&
      blockTrack(src.block) === blockTrack(trigger.targets[0].block);
  }

  document.getElementById('header-status').innerHTML =
    '<span><span class="status-dot"></span>QLab Connected</span>' +
    '<span>Show: ' + data.show + '</span>' +
    '<span>Cue: ' + data.blocks.filter(b => b.type === 'cue').length + '</span>';

  const active = new Map();
  const pendingEnds = new Set();
  const pendingTitles = new Set();
  const titled = new Set();
  const rows = [];

  function mid(tid) {
    const a = active.get(tid);
    return a ? { blockId: a, segment: 'mid' } : { empty: true };
  }

  function addRow(cells, rowClass) {
    rows.push({ cells, rowClass: rowClass || '' });
  }

  function wantTitle(bid) {
    if (!titled.has(bid)) pendingTitles.add(bid);
  }

  function emitTitles() {
    if (pendingTitles.size === 0) return;
    const cells = trackIds.map(tid => {
      const t = [...pendingTitles].find(bid => blockTrack(bid) === tid);
      return t ? { blockId: t, segment: 'mid', title: blockMap.get(t).name } : mid(tid);
    });
    addRow(cells);
    pendingTitles.forEach(bid => titled.add(bid));
    pendingTitles.clear();
  }

  function flush() {
    emitTitles();
    if (pendingEnds.size === 0) return;

    const toEnd = [...pendingEnds].filter(bid => !triggerSourceSet.has(ref(bid, 'END')));
    if (toEnd.length === 0) return;

    const cells = trackIds.map(tid => {
      const e = toEnd.find(bid => blockTrack(bid) === tid);
      return e ? { blockId: e, segment: 'end', event: 'END' } : mid(tid);
    });
    addRow(cells);
    toEnd.forEach(bid => { active.delete(blockTrack(bid)); pendingEnds.delete(bid); });
  }

  function processTrigger(trigger) {
    const src = trigger.source;
    const isCue = src.signal === 'GO';

    flush();

    if (isChain(trigger)) {
      const tid = blockTrack(src.block);
      const tgt = trigger.targets[0].block;
      if (active.get(tid) === src.block || pendingEnds.has(src.block)) {
        pendingEnds.delete(src.block);
        const endCells = trackIds.map(t =>
          t === tid ? { blockId: src.block, segment: 'end', event: 'END' } : mid(t)
        );
        addRow(endCells);
        active.delete(tid);
      }
      active.set(tid, tgt);
      wantTitle(tgt);
      const startCells = trackIds.map(t =>
        t === tid ? { blockId: tgt, segment: 'start', event: 'START' } : mid(t)
      );
      addRow(startCells);
      return;
    }

    if (!isCue && src.signal === 'START' && active.get(blockTrack(src.block)) !== src.block) {
      active.set(blockTrack(src.block), src.block);
    }

    emitTitles();

    const rowClass = isCue ? 'cue-row' : 'sig-row';

    const targetMap = new Map();
    trigger.targets.forEach(t => targetMap.set(t.block, t.hook));

    const directEnds = [];

    const cells = trackIds.map(tid => {
      if (isCue && tid === CUE_TRACK)
        return { cueLabel: blockMap.get(src.block).name };

      if (!isCue && blockTrack(src.block) === tid) {
        const alreadyActive = active.get(tid) === src.block;
        const seg = alreadyActive ? 'mid' : src.signal === 'START' ? 'start' : src.signal === 'END' ? 'end' : 'mid';
        return { blockId: src.block, segment: seg, event: src.signal, isSignal: true };
      }

      const entry = [...targetMap.entries()].find(([bid]) => blockTrack(bid) === tid);
      if (entry) {
        const [bid, hook] = entry;
        const isHook = !isCue;
        if (hook === 'START') {
          active.set(tid, bid);
          wantTitle(bid);
          return { blockId: bid, segment: 'start', event: 'START', isHook };
        }
        if (hook === 'END') {
          directEnds.push(bid);
          return { blockId: bid, segment: 'end', event: 'END', isHook };
        }
        if (hook === 'FADE_OUT') {
          pendingEnds.add(bid);
          return { blockId: bid, segment: 'mid', event: 'FADE_OUT' };
        }
      }

      return mid(tid);
    });

    addRow(cells, rowClass);

    directEnds.forEach(bid => active.delete(blockTrack(bid)));

    if (!isCue) {
      if (src.signal === 'START' && !pendingTitles.has(src.block)) wantTitle(src.block);
      if (src.signal === 'FADE_OUT') pendingEnds.add(src.block);
      if (src.signal === 'END') {
        active.delete(blockTrack(src.block));
        pendingEnds.delete(src.block);
      }
    }
  }

  data.triggers.forEach(t => processTrigger(t));
  flush();
  emitTitles();

  const stillActive = [];
  for (const [tid, bid] of active) {
    if (tid !== CUE_TRACK) stillActive.push(bid);
  }
  if (stillActive.length > 0) {
    const cells = trackIds.map(tid => {
      const bid = stillActive.find(b => blockTrack(b) === tid);
      return bid ? { blockId: bid, segment: 'mid', infinity: true } : mid(tid);
    });
    addRow(cells);
  }

  const timeline = document.getElementById('timeline');
  const trackNames = { [CUE_TRACK]: 'Cue' };
  data.tracks.forEach(t => { trackNames[t.id] = t.name; });
  timeline.style.gridTemplateColumns = 'repeat(' + trackIds.length + ', 140px)';

  trackIds.forEach(tid => {
    const th = document.createElement('div');
    th.className = 'track-header';
    th.textContent = trackNames[tid];
    timeline.appendChild(th);
  });

  rows.forEach(row => {
    row.cells.forEach(cell => {
      const div = document.createElement('div');
      let cls = 'cell';
      if (row.rowClass) cls += ' ' + row.rowClass;

      if (cell.cueLabel) {
        div.className = cls;
        const label = document.createElement('div');
        label.className = 'cue-label';
        label.textContent = cell.cueLabel;
        div.appendChild(label);
      } else if (cell.empty) {
        div.className = cls;
      } else if (cell.title) {
        div.className = cls;
        const block = document.createElement('div');
        block.className = 'block block-mid ' + blockMap.get(cell.blockId).type;
        const t = document.createElement('div');
        t.className = 'title';
        t.textContent = cell.title;
        block.appendChild(t);
        div.appendChild(block);
      } else if (cell.infinity) {
        div.className = cls + ' infinity-cell';
        const block = document.createElement('div');
        block.className = 'block block-mid ' + blockMap.get(cell.blockId).type;
        div.appendChild(block);
        const marker = document.createElement('div');
        marker.className = 'infinity-marker';
        marker.innerHTML = '&#x223F;&#x223F;&#x223F;';
        div.appendChild(marker);
      } else {
        div.className = cls;
        const seg = cell.segment || 'mid';
        const block = document.createElement('div');
        block.className = 'block block-' + seg + ' ' + blockMap.get(cell.blockId).type;
        if (cell.event) {
          const hook = document.createElement('div');
          let hookCls = 'hook';
          if (cell.isSignal) hookCls += ' sig';
          else if (cell.isHook) hookCls += ' hk';
          hook.className = hookCls;
          hook.textContent = cell.event.replace('_', ' ');
          block.appendChild(hook);
        }
        div.appendChild(block);
      }

      timeline.appendChild(div);
    });
  });
}
</script>
</body>
</html>
