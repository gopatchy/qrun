<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Qrun</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #111;
  --bg2: #1a1a1a;
  --fg: #eee;
  --fg-dim: #888;
  --border: #333;
  --cue-color: #f72;
  --cue-bg: rgba(58, 24, 0, 0.7);
  --light-color: #c8e;
  --light-bg: rgba(42, 10, 42, 0.55);
  --video-color: #4d4;
  --video-bg: rgba(10, 42, 10, 0.55);
  --audio-color: #58f;
  --audio-bg: rgba(10, 10, 42, 0.55);
  --delay-color: #999;
  --delay-bg: rgba(26, 26, 26, 0.55);
  --infinity-color: #666;
}

html, body {
  background: var(--bg);
  color: var(--fg);
  font-family: "SF Mono", "Menlo", "Consolas", "DejaVu Sans Mono", monospace;
  font-size: 13px;
  line-height: 1.4;
  height: 100%;
  overflow: hidden;
}

.app { display: flex; flex-direction: column; height: 100%; }

header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 16px; background: var(--bg2);
  border-bottom: 1px solid var(--border); flex-shrink: 0;
}
header h1 { font-size: 16px; font-weight: 600; letter-spacing: 0.05em; }
.header-status { display: flex; gap: 16px; align-items: center; font-size: 12px; color: var(--fg-dim); }
.status-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #4d4; margin-right: 4px; }

.timeline-container { flex: 1; overflow: auto; }

.timeline {
  display: grid;
  grid-auto-rows: 24px;
}

.track-header {
  position: sticky; top: 0; z-index: 10;
  padding: 6px 8px; font-size: 10px; font-weight: 600;
  text-transform: uppercase; letter-spacing: 0.08em; text-align: center;
  border-bottom: 2px solid var(--border); border-right: 1px solid var(--border);
  background: var(--bg2); color: var(--fg-dim);
}

.cell {
  border-right: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  padding: 0; position: relative;
  display: flex; flex-direction: column;
  justify-content: center;
}

.block {
  margin: 0 3px; position: relative; z-index: 1; flex: 1;
  display: flex; align-items: center; justify-content: center;
}
.block-start {
  border-top: 2px solid; border-left: 2px solid; border-right: 2px solid;
  border-top-left-radius: 3px; border-top-right-radius: 3px;
  margin-top: 1px; margin-bottom: -1px;
}
.block-mid {
  border-left: 2px solid; border-right: 2px solid;
  margin-top: -1px; margin-bottom: -1px; min-height: 4px;
}
.block-end {
  border-bottom: 2px solid; border-left: 2px solid; border-right: 2px solid;
  border-bottom-left-radius: 3px; border-bottom-right-radius: 3px;
  margin-top: -1px; margin-bottom: 1px;
}
.block-single {
  border: 2px solid; border-radius: 3px; margin: 1px 3px;
}

.block.cue { color: var(--cue-color); border-color: var(--cue-color); background: var(--cue-bg); }

.cell.cue-row {
  background: rgba(255, 119, 34, 0.12);
  border-top: 1px solid var(--cue-color);
  border-bottom: 1px solid var(--cue-color);
}

.cell.sig-row {
  background: rgba(255, 204, 0, 0.07);
  border-top: 1px solid rgba(255, 204, 0, 0.3);
  border-bottom: 1px solid rgba(255, 204, 0, 0.3);
}
.block.light { color: var(--light-color); border-color: var(--light-color); background: var(--light-bg); }
.block.video { color: var(--video-color); border-color: var(--video-color); background: var(--video-bg); }
.block.audio { color: var(--audio-color); border-color: var(--audio-color); background: var(--audio-bg); }
.block.delay { color: var(--delay-color); border-color: var(--delay-color); background: var(--delay-bg); }

.hook {
  font-size: 8px; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.06em; opacity: 0.8;
}

.sig {
  background: #fc0;
  color: #000;
  border-radius: 2px;
  padding: 0 6px;
  font-weight: 700;
}

.hk {
  padding: 0 5px;
}

.title {
  text-align: center; font-size: 11px; font-weight: 500;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

.cue-label {
  font-size: 10px; font-weight: 600; color: var(--cue-color);
  padding: 0 4px;
}

.infinity-cell { position: relative; overflow: hidden; }
.infinity-cell .block { border-bottom: none !important; border-bottom-left-radius: 0 !important; border-bottom-right-radius: 0 !important; }
.infinity-marker {
  position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);
  font-size: 9px; color: var(--infinity-color);
  letter-spacing: 0.1em; z-index: 1; white-space: nowrap;
}
</style>
</head>
<body>
<div class="app">
<header>
  <h1>QRUN</h1>
  <div class="header-status" id="header-status"></div>
</header>
<div class="timeline-container">
<div class="timeline" id="timeline"></div>
</div>
</div>
<script>
fetch('show.json').then(r => r.json()).then(render);

function render(data) {
  const blocks = new Map(data.blocks.map(b => [b.id, b]));
  const trackById = new Map(data.tracks.map(t => [t.id, t]));
  const getTrack = id => blocks.get(id).type === 'cue' ? '_cue' : blocks.get(id).track;
  const trackIds = ['_cue', ...data.tracks.map(t => t.id)];
  
  const startSigs = new Map();
  data.triggers.forEach(t => t.source.signal === 'START' && startSigs.set(t.source.block, t.targets));

  const isChain = t => {
    if (t.source.signal !== 'END' || t.targets.length !== 1) return false;
    return t.targets[0].hook === 'START' && getTrack(t.source.block) === getTrack(t.targets[0].block);
  };
  
  const expand = (tgts) => {
    const res = new Map();
    const q = [...tgts];
    while(q.length) {
      const {block, hook} = q.shift();
      if (!res.has(block)) { res.set(block, hook); if (hook === 'START' && startSigs.has(block)) q.push(...startSigs.get(block)); }
    }
    return res;
  };

  let active = new Map(), pending = new Set(), rows = [], noTitle = new Set();

  const addRow = (cells, cls = '') => {
    const last = rows[rows.length-1];
    if (last && last.rowClass === cls) {
      let merge = true;
      for (let i=0; i<cells.length; i++) {
        if ((cells[i].event||cells[i].cueLabel) && (last.cells[i].event||last.cells[i].cueLabel)) { merge = false; break; }
      }
      if (merge) {
        cells.forEach((c, i) => { if (c.event||c.cueLabel) last.cells[i] = c; });
        return;
      }
    }
    rows.push({ cells, rowClass: cls });
  };

  const mid = tid => active.has(tid) ? { blockId: active.get(tid), segment: 'mid' } : { empty: true };
  const mkCells = evs => trackIds.map(tid => evs.get(tid) || mid(tid));
  const applySideEffect = (map, blockId, hook) => {
    const tid = getTrack(blockId);
    if (map.has(tid)) return;
    if (hook === 'START') { active.set(tid, blockId); map.set(tid, { blockId, segment: 'start', event: 'START', isHook: true }); }
    else if (hook === 'END') { map.set(tid, { blockId, segment: 'end', event: 'END', isHook: true }); active.delete(tid); }
    else if (hook === 'FADE_OUT') { map.set(tid, { blockId, segment: 'mid', event: 'FADE_OUT' }); pending.add(blockId); }
  };

  const flush = () => {
    const toEnd = [...pending].filter(bid => !data.triggers.some(t => t.source.block === bid && t.source.signal === 'END'));
    if (!toEnd.length) return;
    const evs = new Map();
    toEnd.forEach(bid => evs.set(getTrack(bid), { blockId: bid, segment: 'end', event: 'END' }));
    addRow(mkCells(evs));
    toEnd.forEach(bid => { active.delete(getTrack(bid)); pending.delete(bid); });
  };

  for (let i = 0; i < data.triggers.length; i++) {
    const t = data.triggers[i];
    if (t.source.signal === 'START') continue;
    
    if (isChain(t)) {
      if (startSigs.has(t.targets[0].block)) {
        flush();
        const s = t.source.block, tgt = t.targets[0].block, tid = getTrack(tgt);
        
        const ends = new Map();
        if (active.get(tid) === s || pending.has(s)) {
          pending.delete(s); active.delete(tid);
          ends.set(tid, { blockId: s, segment: 'end', event: 'END' });
        }
        if (ends.size) addRow(mkCells(ends));

        active.set(tid, tgt);
        const sideEffects = new Map(), starts = new Map();
        expand(startSigs.get(tgt)).forEach((h, b) => sideEffects.set(b, h));
        starts.set(tid, { blockId: tgt, segment: 'start', event: 'START', isSignal: true });
        
        noTitle.add(rows.length-1);
        sideEffects.forEach((h, b) => applySideEffect(starts, b, h));
        addRow(mkCells(starts), sideEffects.size ? 'sig-row' : '');
        continue;
      }
      
      let batch = [t], tracks = new Set([getTrack(t.source.block)]), j = i + 1;
      while (j < data.triggers.length) {
        const c = data.triggers[j];
        if (c.source.signal === 'START') { j++; continue; }
        if (!isChain(c) || tracks.has(getTrack(c.source.block)) || startSigs.has(c.targets[0].block)) break;
        tracks.add(getTrack(c.source.block)); batch.push(c); j++;
      }
      
      flush();
      const ends = new Map();
      batch.forEach(c => {
        const s = c.source.block, tid = getTrack(s);
        if (active.get(tid) === s || pending.has(s)) {
          pending.delete(s); active.delete(tid);
          ends.set(tid, { blockId: s, segment: 'end', event: 'END' });
        }
      });
      if (ends.size) addRow(mkCells(ends));
      
      const starts = new Map(), sideEffects = new Map();
      batch.forEach(c => {
        const tgt = c.targets[0].block, tid = getTrack(tgt);
        active.set(tid, tgt);
        const hasSigs = startSigs.has(tgt);
        if (hasSigs) expand(startSigs.get(tgt)).forEach((h, b) => sideEffects.set(b, h));
        starts.set(tid, { blockId: tgt, segment: 'start', event: 'START', isSignal: hasSigs });
      });
      noTitle.add(rows.length-1);

      sideEffects.forEach((h, b) => applySideEffect(starts, b, h));

      addRow(mkCells(starts), sideEffects.size ? 'sig-row' : '');
      i = j - 1;
      continue;
    }
    
    flush();
    const isCue = t.source.signal === 'GO';
    const tgts = new Map();
    t.targets.forEach(tx => tgts.set(tx.block, tx.hook));
    expand(t.targets).forEach((h, b) => tgts.set(b, h));
    
    const evs = new Map(), directEnds = [];
    if (isCue) evs.set('_cue', { cueLabel: blocks.get(t.source.block).name });
    else if (getTrack(t.source.block) !== '_cue') evs.set(getTrack(t.source.block), { blockId: t.source.block, segment: t.source.signal === 'END' ? 'end' : 'mid', event: t.source.signal, isSignal: true });

    tgts.forEach((h, b) => {
      const tid = getTrack(b);
      if (evs.has(tid)) return;
      if (h === 'START') { active.set(tid, b); evs.set(tid, { blockId: b, segment: 'start', event: 'START', isHook: !isCue }); }
      else if (h === 'END') { evs.set(tid, { blockId: b, segment: 'end', event: 'END', isHook: !isCue, directEnd: true }); }
      else if (h === 'FADE_OUT') { evs.set(tid, { blockId: b, segment: 'mid', event: 'FADE_OUT' }); pending.add(b); }
    });
    
    const cells = mkCells(evs);
    evs.forEach((c, tid) => { if(c.directEnd) { directEnds.push(c.blockId); delete c.directEnd; } });
    addRow(cells, isCue ? 'cue-row' : 'sig-row');
    directEnds.forEach(b => active.delete(getTrack(b)));
    
    if (!isCue) {
      if (t.source.signal === 'FADE_OUT') pending.add(t.source.block);
      if (t.source.signal === 'END') { active.delete(getTrack(t.source.block)); pending.delete(t.source.block); }
    }
  }
  flush();

  const activeEvs = new Map();
  [...active].forEach(([tid, bid]) => { if (tid !== '_cue') activeEvs.set(tid, { blockId: bid, segment: 'mid', infinity: true }); });
  if (activeEvs.size) addRow(mkCells(activeEvs));

  const ranges = new Map();
  rows.forEach((row, rIdx) => row.cells.forEach(c => {
    if (!c.blockId) return;
    const r = ranges.get(c.blockId) || { first: rIdx, last: rIdx, start: -1, end: Infinity };
    r.last = rIdx;
    if (c.event === 'START') r.start = Math.max(r.start, rIdx);
    if (['END', 'FADE_OUT'].includes(c.event)) r.end = Math.min(r.end, rIdx);
    ranges.set(c.blockId, r);
  }));

  const titles = [...ranges.entries()].filter(([bid]) => blocks.get(bid).type !== 'cue').map(([bid, r]) => {
    const s = r.start >= 0 ? r.start : r.first, e = r.end !== Infinity ? r.end : r.last;
    return { bid, track: getTrack(bid), s, e: r.end !== Infinity ? r.end - 1 : e, pos: Math.floor((s + (r.end !== Infinity ? r.end - 1 : e)) / 2) };
  }).sort((a,b) => a.pos - b.pos);

  const groups = [];
  titles.forEach(t => {
    let best = -1, bestDist = Infinity;
    for (let i = 0; i < groups.length; i++) {
      const g = groups[i];
      const iS = Math.max(g.s, t.s), iE = Math.min(g.e, t.e);
      if (iS > iE || g.titles.some(gt => gt.track === t.track)) continue;
      let cand = g.pos; if (cand < iS || cand > iE) cand = Math.floor((iS + iE) / 2);
      if (noTitle.has(cand)) {
        let f = false; for (let r = cand + 1; r <= iE; r++) { if (!noTitle.has(r)) { cand = r; f = true; break; } }
        if (!f) continue;
      }
      const dist = Math.abs(cand - t.pos);
      if (dist < bestDist) { best = i; bestDist = dist; }
    }
    if (best >= 0) {
      const g = groups[best];
      g.s = Math.max(g.s, t.s); g.e = Math.min(g.e, t.e);
      if (g.pos < g.s || g.pos > g.e) g.pos = Math.floor((g.s + g.e) / 2);
      if (noTitle.has(g.pos)) { for (let r = g.pos + 1; r <= g.e; r++) if (!noTitle.has(r)) { g.pos = r; break; } }
      g.titles.push(t);
    } else {
      let p = t.pos; if (noTitle.has(p)) { for (let r = p + 1; r <= t.e; r++) if (!noTitle.has(r)) { p = r; break; } }
      groups.push({ pos: p, s: t.s, e: t.e, titles: [t] });
    }
  });
  groups.sort((a,b) => a.pos - b.pos);

  const finalRows = [];
  let gIdx = 0;
  rows.forEach((r, i) => {
    finalRows.push(r);
    while (gIdx < groups.length && groups[gIdx].pos === i) {
      const g = groups[gIdx];
      finalRows.push({ cells: trackIds.map((tid, col) => {
        const t = g.titles.find(gt => gt.track === tid);
        if (t) return { blockId: t.bid, segment: 'mid', title: blocks.get(t.bid).name };
        const p = r.cells[col];
        return p.blockId && p.segment !== 'end' ? { blockId: p.blockId, segment: 'mid' } : { empty: true };
      }) });
      gIdx++;
    }
  });

  document.getElementById('header-status').innerHTML =
    `<span><span class="status-dot"></span>QLab Connected</span>` +
    `<span>Show: ${data.show}</span>` +
    `<span>Cue: ${data.blocks.filter(b => b.type === 'cue').length}</span>`;

  const timeline = document.getElementById('timeline');
  timeline.style.gridTemplateColumns = `repeat(${trackIds.length}, 140px)`;
  trackIds.forEach(tid => {
    const el = document.createElement('div');
    el.className = 'track-header';
    el.textContent = tid === '_cue' ? 'Cue' : (trackById.get(tid)||{}).name;
    timeline.appendChild(el);
  });

  finalRows.forEach(row => row.cells.forEach(c => {
    const div = document.createElement('div');
    div.className = 'cell ' + (row.rowClass || '');
    if (c.cueLabel) {
      div.innerHTML = `<div class="cue-label">${c.cueLabel}</div>`;
    } else if (c.title) {
      div.innerHTML = `<div class="block block-mid ${blocks.get(c.blockId).type}"><div class="title">${c.title}</div></div>`;
    } else if (c.blockId) {
      const b = blocks.get(c.blockId);
      const seg = c.infinity ? 'mid' : (c.segment || 'mid');
      div.className += c.infinity ? ' infinity-cell' : '';
      let inner = `<div class="block block-${seg} ${b.type}">`;
      if (c.event) {
        let hCls = 'hook' + (c.isSignal ? ' sig' : (c.isHook ? ' hk' : ''));
        inner += `<div class="${hCls}">${c.event.replace('_', ' ')}</div>`;
      }
      inner += `</div>`;
      if (c.infinity) inner += `<div class="infinity-marker">&#x223F;&#x223F;&#x223F;</div>`;
      div.innerHTML = inner;
    }
    timeline.appendChild(div);
  }));
}
</script>
</body>
</html>
