<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Qrun</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #111;
  --bg2: #1a1a1a;
  --fg: #eee;
  --fg-dim: #888;
  --border: #333;
  --cue-color: #f72;
  --cue-bg: rgba(58, 24, 0, 0.7);
  --light-color: #c8e;
  --light-bg: rgba(42, 10, 42, 0.55);
  --video-color: #4d4;
  --video-bg: rgba(10, 42, 10, 0.55);
  --audio-color: #58f;
  --audio-bg: rgba(10, 10, 42, 0.55);
  --delay-color: #999;
  --delay-bg: rgba(26, 26, 26, 0.55);
  --infinity-color: #666;
}

html, body {
  background: var(--bg);
  color: var(--fg);
  font-family: "SF Mono", "Menlo", "Consolas", "DejaVu Sans Mono", monospace;
  font-size: 13px;
  line-height: 1.4;
  height: 100%;
  overflow: hidden;
}

.app { display: flex; flex-direction: column; height: 100%; }

header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 16px; background: var(--bg2);
  border-bottom: 1px solid var(--border); flex-shrink: 0;
}
header h1 { font-size: 16px; font-weight: 600; letter-spacing: 0.05em; }
.header-status { display: flex; gap: 16px; align-items: center; font-size: 12px; color: var(--fg-dim); }
.status-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #4d4; margin-right: 4px; }

.timeline-container { flex: 1; overflow: auto; }

.timeline {
  display: grid;
  grid-auto-rows: 24px;
}

.track-header {
  position: sticky; top: 0; z-index: 10;
  padding: 6px 8px; font-size: 10px; font-weight: 600;
  text-transform: uppercase; letter-spacing: 0.08em; text-align: center;
  border-bottom: 2px solid var(--border); border-right: 1px solid var(--border);
  background: var(--bg2); color: var(--fg-dim);
}

.cell {
  border-right: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  padding: 0; position: relative;
  display: flex; flex-direction: column;
  justify-content: center;
}

.block {
  margin: 0 3px; position: relative; z-index: 1; flex: 1;
  display: flex; align-items: center; justify-content: center;
}
.block-start {
  border-top: 2px solid; border-left: 2px solid; border-right: 2px solid;
  border-top-left-radius: 3px; border-top-right-radius: 3px;
  margin-top: 1px; margin-bottom: -1px;
}
.block-mid {
  border-left: 2px solid; border-right: 2px solid;
  margin-top: -1px; margin-bottom: -1px; min-height: 4px;
}
.block-end {
  border-bottom: 2px solid; border-left: 2px solid; border-right: 2px solid;
  border-bottom-left-radius: 3px; border-bottom-right-radius: 3px;
  margin-top: -1px; margin-bottom: 1px;
}
.block-single {
  border: 2px solid; border-radius: 3px; margin: 1px 3px;
}

.block.cue { color: var(--cue-color); border-color: var(--cue-color); background: var(--cue-bg); }

.cell.cue-row {
  background: rgba(255, 119, 34, 0.12);
  border-top: 1px solid var(--cue-color);
  border-bottom: 1px solid var(--cue-color);
}

.cell.sig-row {
  background: rgba(255, 204, 0, 0.07);
  border-top: 1px solid rgba(255, 204, 0, 0.3);
  border-bottom: 1px solid rgba(255, 204, 0, 0.3);
}
.block.light { color: var(--light-color); border-color: var(--light-color); background: var(--light-bg); }
.block.video { color: var(--video-color); border-color: var(--video-color); background: var(--video-bg); }
.block.audio { color: var(--audio-color); border-color: var(--audio-color); background: var(--audio-bg); }
.block.delay { color: var(--delay-color); border-color: var(--delay-color); background: var(--delay-bg); }

.hook {
  font-size: 8px; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.06em; opacity: 0.8;
}

.sig {
  background: #fc0;
  color: #000;
  border-radius: 2px;
  padding: 0 6px;
  font-weight: 700;
}

.hk {
  padding: 0 5px;
}

.title {
  text-align: center; font-size: 11px; font-weight: 500;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

.cue-label {
  font-size: 10px; font-weight: 600; color: var(--cue-color);
  padding: 0 4px;
}

.infinity-cell { position: relative; overflow: hidden; }
.infinity-cell .block { border-bottom: none !important; border-bottom-left-radius: 0 !important; border-bottom-right-radius: 0 !important; }
.infinity-marker {
  position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%);
  font-size: 9px; color: var(--infinity-color);
  letter-spacing: 0.1em; z-index: 1; white-space: nowrap;
}
</style>
</head>
<body>
<div class="app">
<header>
  <h1>QRUN</h1>
  <div class="header-status" id="header-status"></div>
</header>
<div class="timeline-container">
<div class="timeline" id="timeline"></div>
</div>
</div>
<script>
fetch('show.json').then(r => r.json()).then(render);

function render(data) {
  const blockMap = new Map(data.blocks.map(b => [b.id, b]));
  const CUE_TRACK = '_cue';
  const trackIds = [CUE_TRACK, ...data.tracks.map(t => t.id)];

  function ref(b, s) { return b + ':' + s; }

  const triggerSourceSet = new Set();
  const startSignalMap = new Map();
  data.triggers.forEach(t => {
    triggerSourceSet.add(ref(t.source.block, t.source.signal));
    if (t.source.signal === 'START') startSignalMap.set(t.source.block, t.targets);
  });

  function blockTrack(bid) {
    const b = blockMap.get(bid);
    return b.type === 'cue' ? CUE_TRACK : b.track;
  }

  function isChain(trigger) {
    const src = trigger.source;
    if (src.signal !== 'END' || trigger.targets.length !== 1) return false;
    return trigger.targets[0].hook === 'START' &&
      blockTrack(src.block) === blockTrack(trigger.targets[0].block);
  }

  document.getElementById('header-status').innerHTML =
    '<span><span class="status-dot"></span>QLab Connected</span>' +
    '<span>Show: ' + data.show + '</span>' +
    '<span>Cue: ' + data.blocks.filter(b => b.type === 'cue').length + '</span>';

  const active = new Map();
  const pendingEnds = new Set();
  const noTitleAfter = new Set();
  const rows = [];

  function mid(tid) {
    const a = active.get(tid);
    return a ? { blockId: a, segment: 'mid' } : { empty: true };
  }

  function addRow(cells, rowClass) {
    rowClass = rowClass || '';
    if (rows.length > 0) {
      const last = rows[rows.length - 1];
      if (last.rowClass === rowClass) {
        let canMerge = true;
        for (let i = 0; i < cells.length; i++) {
          if ((cells[i].event || cells[i].cueLabel) && (last.cells[i].event || last.cells[i].cueLabel)) {
            canMerge = false;
            break;
          }
        }
        if (canMerge) {
          for (let i = 0; i < cells.length; i++) {
            if (cells[i].event || cells[i].cueLabel) last.cells[i] = cells[i];
          }
          return;
        }
      }
    }
    rows.push({ cells, rowClass });
  }

  function flush() {
    if (pendingEnds.size === 0) return;

    const toEnd = [...pendingEnds].filter(bid => !triggerSourceSet.has(ref(bid, 'END')));
    if (toEnd.length === 0) return;

    const cells = trackIds.map(tid => {
      const e = toEnd.find(bid => blockTrack(bid) === tid);
      return e ? { blockId: e, segment: 'end', event: 'END' } : mid(tid);
    });
    addRow(cells);
    toEnd.forEach(bid => { active.delete(blockTrack(bid)); pendingEnds.delete(bid); });
  }

  function expandTargets(targetMap) {
    const toExpand = [...targetMap.entries()].filter(([_, hook]) => hook === 'START');
    toExpand.forEach(([bid]) => {
      const extras = startSignalMap.get(bid);
      if (extras) extras.forEach(et => { if (!targetMap.has(et.block)) targetMap.set(et.block, et.hook); });
    });
  }

  function applyTargets(targetMap, tid, isCue) {
    const entry = [...targetMap.entries()].find(([bid]) => blockTrack(bid) === tid);
    if (!entry) return null;
    const [bid, hook] = entry;
    const isHook = !isCue;
    if (hook === 'START') {
      active.set(tid, bid);
      return { blockId: bid, segment: 'start', event: 'START', isHook };
    }
    if (hook === 'END') return { blockId: bid, segment: 'end', event: 'END', isHook, directEnd: true };
    if (hook === 'FADE_OUT') {
      pendingEnds.add(bid);
      return { blockId: bid, segment: 'mid', event: 'FADE_OUT' };
    }
    return null;
  }

  function processChainBatch(chains) {
    flush();
    const chainEnds = [];
    for (const trigger of chains) {
      const src = trigger.source.block;
      const tid = blockTrack(src);
      if (active.get(tid) === src || pendingEnds.has(src)) {
        pendingEnds.delete(src);
        chainEnds.push({ block: src, track: tid });
        active.delete(tid);
      }
    }
    if (chainEnds.length > 0) {
      const endCells = trackIds.map(t => {
        const e = chainEnds.find(ce => ce.track === t);
        return e ? { blockId: e.block, segment: 'end', event: 'END' } : mid(t);
      });
      addRow(endCells);
    }
    const chainStarts = new Map();
    const combinedTargets = new Map();
    for (const trigger of chains) {
      const tgt = trigger.targets[0].block;
      const tid = blockTrack(tgt);
      active.set(tid, tgt);
      const targetMap = new Map();
      const extras = startSignalMap.get(tgt);
      if (extras) extras.forEach(et => targetMap.set(et.block, et.hook));
      expandTargets(targetMap);
      chainStarts.set(tid, { blockId: tgt, hasTargets: targetMap.size > 0 });
      for (const [bid, hook] of targetMap) {
        if (!combinedTargets.has(bid)) combinedTargets.set(bid, hook);
      }
    }
    const hasAnyTargets = [...chainStarts.values()].some(cs => cs.hasTargets);
    noTitleAfter.add(rows.length - 1);
    const directEnds = [];
    const startCells = trackIds.map(t => {
      const cs = chainStarts.get(t);
      if (cs) return { blockId: cs.blockId, segment: 'start', event: 'START', isSignal: cs.hasTargets };
      const cell = applyTargets(combinedTargets, t, false);
      if (cell) { if (cell.directEnd) { directEnds.push(cell.blockId); delete cell.directEnd; } return cell; }
      return mid(t);
    });
    addRow(startCells, hasAnyTargets ? 'sig-row' : '');
    directEnds.forEach(bid => active.delete(blockTrack(bid)));
  }

  function processTrigger(trigger) {
    const src = trigger.source;
    const isCue = src.signal === 'GO';

    flush();

    const rowClass = isCue ? 'cue-row' : 'sig-row';

    const targetMap = new Map();
    trigger.targets.forEach(t => targetMap.set(t.block, t.hook));
    expandTargets(targetMap);

    const directEnds = [];

    const cells = trackIds.map(tid => {
      if (isCue && tid === CUE_TRACK)
        return { cueLabel: blockMap.get(src.block).name };

      if (!isCue && blockTrack(src.block) === tid) {
        const seg = src.signal === 'END' ? 'end' : 'mid';
        return { blockId: src.block, segment: seg, event: src.signal, isSignal: true };
      }

      const cell = applyTargets(targetMap, tid, isCue);
      if (cell) { if (cell.directEnd) { directEnds.push(cell.blockId); delete cell.directEnd; } return cell; }

      return mid(tid);
    });

    addRow(cells, rowClass);

    directEnds.forEach(bid => active.delete(blockTrack(bid)));

    if (!isCue) {
      if (src.signal === 'FADE_OUT') pendingEnds.add(src.block);
      if (src.signal === 'END') {
        active.delete(blockTrack(src.block));
        pendingEnds.delete(src.block);
      }
    }
  }

  let triggerIdx = 0;
  while (triggerIdx < data.triggers.length) {
    const t = data.triggers[triggerIdx];
    if (t.source.signal === 'START') { triggerIdx++; continue; }
    if (isChain(t)) {
      if (startSignalMap.has(t.targets[0].block)) {
        processChainBatch([t]);
        triggerIdx++;
        continue;
      }
      const batch = [t];
      const batchTracks = new Set([blockTrack(t.source.block)]);
      let j = triggerIdx + 1;
      while (j < data.triggers.length) {
        if (data.triggers[j].source.signal === 'START') { j++; continue; }
        if (!isChain(data.triggers[j])) break;
        if (batchTracks.has(blockTrack(data.triggers[j].source.block))) break;
        if (startSignalMap.has(data.triggers[j].targets[0].block)) break;
        batchTracks.add(blockTrack(data.triggers[j].source.block));
        batch.push(data.triggers[j]);
        j++;
      }
      processChainBatch(batch);
      triggerIdx = j;
      continue;
    }
    processTrigger(t);
    triggerIdx++;
  }
  flush();

  const stillActive = [];
  for (const [tid, bid] of active) {
    if (tid !== CUE_TRACK) stillActive.push(bid);
  }
  if (stillActive.length > 0) {
    const cells = trackIds.map(tid => {
      const bid = stillActive.find(b => blockTrack(b) === tid);
      return bid ? { blockId: bid, segment: 'mid', infinity: true } : mid(tid);
    });
    addRow(cells);
  }

  const blockOpenEnd = new Map();
  const blockCloseStart = new Map();
  const blockRange = new Map();
  rows.forEach((row, idx) => {
    row.cells.forEach(cell => {
      if (!cell.blockId) return;
      const bid = cell.blockId;
      if (!blockRange.has(bid)) blockRange.set(bid, { first: idx, last: idx });
      else blockRange.get(bid).last = idx;
      if (cell.event === 'START') blockOpenEnd.set(bid, Math.max(blockOpenEnd.get(bid) || -1, idx));
      if (cell.event === 'FADE_OUT' || cell.event === 'END') blockCloseStart.set(bid, Math.min(blockCloseStart.get(bid) || Infinity, idx));
    });
  });

  const titlesToPlace = [];
  for (const [bid, range] of blockRange) {
    if (blockMap.get(bid).type === 'cue') continue;
    const openEnd = blockOpenEnd.get(bid) || range.first;
    const closeStart = blockCloseStart.has(bid) ? blockCloseStart.get(bid) : Infinity;
    let afterRow;
    if (closeStart === Infinity) {
      afterRow = openEnd;
    } else if (openEnd + 1 <= closeStart - 1) {
      afterRow = Math.floor((openEnd + closeStart - 1) / 2);
    } else {
      afterRow = openEnd;
    }
    titlesToPlace.push({ bid, track: blockTrack(bid), afterRow, validFrom: openEnd, validTo: closeStart === Infinity ? range.last : closeStart - 1 });
  }
  titlesToPlace.sort((a, b) => a.afterRow - b.afterRow);

  const titleGroups = [];
  titlesToPlace.forEach(t => {
    let best = -1;
    let bestDist = Infinity;
    for (let i = 0; i < titleGroups.length; i++) {
      const group = titleGroups[i];
      const iFrom = Math.max(group.validFrom, t.validFrom);
      const iTo = Math.min(group.validTo, t.validTo);
      if (iFrom > iTo) continue;
      if (group.titles.some(gt => gt.track === t.track)) continue;
      let candidate = group.afterRow;
      if (candidate < iFrom || candidate > iTo) candidate = Math.floor((iFrom + iTo) / 2);
      if (noTitleAfter.has(candidate)) {
        let found = false;
        for (let r = candidate + 1; r <= iTo; r++) {
          if (!noTitleAfter.has(r)) { candidate = r; found = true; break; }
        }
        if (!found) continue;
      }
      const dist = Math.abs(candidate - t.afterRow);
      if (dist < bestDist) { best = i; bestDist = dist; }
    }
    if (best >= 0) {
      const group = titleGroups[best];
      group.validFrom = Math.max(group.validFrom, t.validFrom);
      group.validTo = Math.min(group.validTo, t.validTo);
      if (group.afterRow < group.validFrom || group.afterRow > group.validTo) {
        group.afterRow = Math.floor((group.validFrom + group.validTo) / 2);
      }
      if (noTitleAfter.has(group.afterRow)) {
        for (let r = group.afterRow + 1; r <= group.validTo; r++) {
          if (!noTitleAfter.has(r)) { group.afterRow = r; break; }
        }
      }
      group.titles.push({ bid: t.bid, track: t.track });
    } else {
      let pos = t.afterRow;
      if (noTitleAfter.has(pos)) {
        for (let r = pos + 1; r <= t.validTo; r++) {
          if (!noTitleAfter.has(r)) { pos = r; break; }
        }
      }
      titleGroups.push({ afterRow: pos, validFrom: t.validFrom, validTo: t.validTo, titles: [{ bid: t.bid, track: t.track }] });
    }
  });
  titleGroups.sort((a, b) => a.afterRow - b.afterRow);

  const finalRows = [];
  let tgIdx = 0;
  rows.forEach((row, idx) => {
    finalRows.push(row);
    while (tgIdx < titleGroups.length && titleGroups[tgIdx].afterRow === idx) {
      const group = titleGroups[tgIdx];
      const titleCells = trackIds.map((tid, colIdx) => {
        const t = group.titles.find(gt => gt.track === tid);
        if (t) return { blockId: t.bid, segment: 'mid', title: blockMap.get(t.bid).name };
        const prev = row.cells[colIdx];
        if (prev.blockId && prev.segment !== 'end') return { blockId: prev.blockId, segment: 'mid' };
        return { empty: true };
      });
      finalRows.push({ cells: titleCells, rowClass: '' });
      tgIdx++;
    }
  });

  const timeline = document.getElementById('timeline');
  const trackNames = { [CUE_TRACK]: 'Cue' };
  data.tracks.forEach(t => { trackNames[t.id] = t.name; });
  timeline.style.gridTemplateColumns = 'repeat(' + trackIds.length + ', 140px)';

  trackIds.forEach(tid => {
    const th = document.createElement('div');
    th.className = 'track-header';
    th.textContent = trackNames[tid];
    timeline.appendChild(th);
  });

  finalRows.forEach(row => {
    row.cells.forEach(cell => {
      const div = document.createElement('div');
      let cls = 'cell';
      if (row.rowClass) cls += ' ' + row.rowClass;

      if (cell.cueLabel) {
        div.className = cls;
        const label = document.createElement('div');
        label.className = 'cue-label';
        label.textContent = cell.cueLabel;
        div.appendChild(label);
      } else if (cell.empty) {
        div.className = cls;
      } else if (cell.title) {
        div.className = cls;
        const block = document.createElement('div');
        block.className = 'block block-mid ' + blockMap.get(cell.blockId).type;
        const t = document.createElement('div');
        t.className = 'title';
        t.textContent = cell.title;
        block.appendChild(t);
        div.appendChild(block);
      } else if (cell.infinity) {
        div.className = cls + ' infinity-cell';
        const block = document.createElement('div');
        block.className = 'block block-mid ' + blockMap.get(cell.blockId).type;
        div.appendChild(block);
        const marker = document.createElement('div');
        marker.className = 'infinity-marker';
        marker.innerHTML = '&#x223F;&#x223F;&#x223F;';
        div.appendChild(marker);
      } else {
        div.className = cls;
        const seg = cell.segment || 'mid';
        const block = document.createElement('div');
        block.className = 'block block-' + seg + ' ' + blockMap.get(cell.blockId).type;
        if (cell.event) {
          const hook = document.createElement('div');
          let hookCls = 'hook';
          if (cell.isSignal) hookCls += ' sig';
          else if (cell.isHook) hookCls += ' hk';
          hook.className = hookCls;
          hook.textContent = cell.event.replace('_', ' ');
          block.appendChild(hook);
        }
        div.appendChild(block);
      }

      timeline.appendChild(div);
    });
  });
}
</script>
</body>
</html>
